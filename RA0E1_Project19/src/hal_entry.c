#include "hal_data.h"
#include <stdio.h>
FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER


fsp_err_t err = FSP_SUCCESS;
volatile bool uart_send_complete_flag = false;
void user_uart_callback (uart_callback_args_t * p_args)
{
    if(p_args->event == UART_EVENT_TX_COMPLETE)
    {
        uart_send_complete_flag = true;
    }
}

#ifdef __GNUC__                                 //串口重定向
    #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
    #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif


PUTCHAR_PROTOTYPE
{
        err = R_UARTA_Write(&g_uart0_ctrl, (uint8_t *)&ch, 1);
        if(FSP_SUCCESS != err) __BKPT();
        while(uart_send_complete_flag == false){}
        uart_send_complete_flag = false;
        return ch;
}

int _write(int fd,char *pBuffer,int size)
{
    for(int i=0;i<size;i++)
    {
        __io_putchar(*pBuffer++);
    }
    return size;
}

volatile bool scan_complete_flag = false;
/* Callback function */
void adc_callback(adc_callback_args_t *p_args)
{
    /* TODO: add your own code here */

    //宏将告知编译器回调函数不使用参数 p_args，从而避免编译器发出警告，
    FSP_PARAMETER_NOT_USED(p_args);
    scan_complete_flag = true;
}


volatile bool scan_complete_flag1 = false;
/* Callback function */
void adc1_callback(adc_callback_args_t *p_args)
{
    /* TODO: add your own code here */

    //宏将告知编译器回调函数不使用参数 p_args，从而避免编译器发出警告，
    FSP_PARAMETER_NOT_USED(p_args);
    scan_complete_flag1 = true;
}




/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    /* Open the transfer instance with initial configuration. */
    err = R_UARTA_Open(&g_uart0_ctrl, &g_uart0_cfg);
    assert(FSP_SUCCESS == err);

    printf("hello!\n");

    uint8_t adc_flag = 0;


    while(1)
    {
        if(adc_flag==0)
        {
            adc_flag=1;
            /* Initializes the module. */
             err = R_ADC_D_Open(&g_adc0_ctrl, &g_adc0_cfg);
             /* Handle any errors. This function should be defined by the user. */
             assert(FSP_SUCCESS == err);

             /* Enable channels. */
             err = R_ADC_D_ScanCfg(&g_adc0_ctrl, &g_adc0_channel_cfg);
             assert(FSP_SUCCESS == err);
             double channel0_ad=0.0;
             double channel1_ad=0.0;
             double channel2_ad=0.0;
             double channel3_ad=0.0;

             uint32_t channel0_sum=0;
             uint32_t channel1_sum=0;
             uint32_t channel2_sum=0;
             uint32_t channel3_sum=0;

             for(int i=0;i<10;i++)
             {
                 /* In software trigger mode, start a scan by calling R_ADC_D_ScanStart(). In other modes, enable hardware
                  * triggers by calling R_ADC_D_ScanStart(). */
                 (void) R_ADC_D_ScanStart(&g_adc0_ctrl);

                 scan_complete_flag = false;
                 while (!scan_complete_flag)
                 {
                     /* Wait for callback to set flag. */
                 }

                 /* Read converted data. */
                 uint16_t channel0_conversion_result;
                 err = R_ADC_D_Read(&g_adc0_ctrl, ADC_CHANNEL_0, &channel0_conversion_result);
                 assert(FSP_SUCCESS == err);
                 channel0_sum+=channel0_conversion_result;

                 /* Read converted data. */
                 uint16_t channel1_conversion_result;
                 err = R_ADC_D_Read(&g_adc0_ctrl, ADC_CHANNEL_1, &channel1_conversion_result);
                 assert(FSP_SUCCESS == err);
                 channel1_sum+=channel1_conversion_result;

                 /* Read converted data. */
                 uint16_t channel2_conversion_result;
                 err = R_ADC_D_Read(&g_adc0_ctrl, ADC_CHANNEL_2, &channel2_conversion_result);
                 assert(FSP_SUCCESS == err);
                 channel2_sum+=channel2_conversion_result;

                 /* Read converted data. */
                 uint16_t channel3_conversion_result;
                 err = R_ADC_D_Read(&g_adc0_ctrl, ADC_CHANNEL_3, &channel3_conversion_result);
                 assert(FSP_SUCCESS == err);
                 channel3_sum+=channel3_conversion_result;
             }

             err = R_ADC_D_Close(&g_adc0_ctrl);
             assert(FSP_SUCCESS == err);

             printf("\n/**************************************************/\n");
             channel0_ad= (double)(channel0_sum/10/4095.0)*3.3;
             printf("ADC_0=%d,voltage_0=%f\n",channel0_sum/10,channel0_ad);

             channel1_ad= (double)(channel1_sum/10/4095.0)*3.3;
             printf("ADC_1=%d,voltage_1=%f\n",channel1_sum/10,channel1_ad);

             channel2_ad= (double)(channel2_sum/10/4095.0)*3.3;
             printf("ADC_2=%d,voltage_2=%f\n",channel2_sum/10,channel2_ad);

             channel3_ad= (double)(channel3_sum/10/4095.0)*3.3;
             printf("ADC_3=%d,voltage_3=%f\n",channel3_sum/10,channel3_ad);
             printf("/**************************************************/\n");

         }
        else
        {
            adc_flag=0;
            /* Initializes the module. */
            err = R_ADC_D_Open(&g_adc1_ctrl, &g_adc1_cfg);
            /* Handle any errors. This function should be defined by the user. */
            assert(FSP_SUCCESS == err);

            /* Enable channels. */
            err = R_ADC_D_ScanCfg(&g_adc1_ctrl, &g_adc1_channel_cfg);
            assert(FSP_SUCCESS == err);

            double channel5_ad=0.0;
            double channel6_ad=0.0;
            uint32_t channel5_sum=0;
            uint32_t channel6_sum=0;
            for(int i=0;i<10;i++)
            {
                /* In software trigger mode, start a scan by calling R_ADC_D_ScanStart(). In other modes, enable hardware
                 * triggers by calling R_ADC_D_ScanStart(). */
                (void) R_ADC_D_ScanStart(&g_adc1_ctrl);

                scan_complete_flag1 = false;
                while (!scan_complete_flag1)
                {
                    /* Wait for callback to set flag. */
                }

                /* Read converted data. */
                uint16_t channel5_conversion_result;
                err = R_ADC_D_Read(&g_adc1_ctrl, ADC_CHANNEL_5, &channel5_conversion_result);
                assert(FSP_SUCCESS == err);
                channel5_sum+=channel5_conversion_result;

                /* Read converted data. */
                uint16_t channel6_conversion_result;
                err = R_ADC_D_Read(&g_adc1_ctrl, ADC_CHANNEL_6, &channel6_conversion_result);
                assert(FSP_SUCCESS == err);
                channel6_sum+=channel6_conversion_result;

            }
            err = R_ADC_D_Close(&g_adc1_ctrl);
            assert(FSP_SUCCESS == err);
            printf("\n/--------------------------------------------------/\n");

            channel5_ad= (double)(channel5_sum/10/4095.0)*3.3;
            printf("ADC_5=%d,voltage_5=%f\n",channel5_sum/10,channel5_ad);

            channel6_ad= (double)(channel6_sum/10/4095.0)*3.3;
            printf("ADC_6=%d,voltage_6=%f\n",channel6_sum/10,channel6_ad);
            printf("/--------------------------------------------------/\n");


        }


    R_BSP_SoftwareDelay (100, BSP_DELAY_UNITS_MILLISECONDS);
    }
















#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);

#if BSP_CFG_SDRAM_ENABLED

        /* Setup SDRAM and initialize it. Must configure pins first. */
        R_BSP_SdramInit(true);
#endif
    }
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif
